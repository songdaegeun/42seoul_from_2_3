/*
LR(1)문법을 충족하려면 
complete_commands, and_or 이 없어야한다.
complete_commands, and_or는 
1번이상 반복되는 and_or이 pipe_sequenc를 실행하기전에 cmd에 대한 논리연산자(&&, ||)의 등장 여부에 따라 다르게 문장을 유도하는 역할을 한다.

일단 문법에서 complete_commands, and_or, term, subshell, command, redirect_list를 없애고,
pipe_sequence로 시작하는 문법(lr_table_grammar_minishell_editing)에 따른 parser(lr_parser) + 문법에서 제거된 부분 따로 parse하면 될 것같다.
전체 parsing(ms_parser())은 아래와 같이 구현한다.

test case: ((cat && echo "hi1") << LIMIT && echo "hi2")

; ms_parser();
0.  readline반환값을 input_symbol,
    lexer를 거친값을 token_arr,
    token_arr를 순회하며 현재까지 읽어들인 token_arr의 요소들을 token_buff,
    ast의 root들과 논리연산자를 선형적으로 연결해놓은 자료구조를 subshell_tree,
    subshell_tree를 순회하며 input_symbol을 모두 실행하는 함수를 output_exec
    라고 하자.
    subshell(자식프로세스)을 나간 후
    부모프로세스에서 자식 프로세스의 subshell root들과 논리연산자들을 선형적으로 연결하는 작업이 재귀적으로 일어난다.
1.  token_arr에 대해 '\0'가 나올때까지 순회한다. 
2.  '('가 나왔을 때 p_stack++하고 현재까지 읽어들인 token_arr의 index를 lr_parser()로 넘기며 호출한다. 
; output_exec()호출 시, 각 subshell에서 사용할 ast는 따로 보관되어야한다.
; 따라서 subshell에 들어갈 때, 즉 lr_parser를 시작할때는 ast를 항상 새로만들고,
; subshell_tree의 root는 초기화되고, subshell_tree의 exec_base에 ast의 root를 대입한다.
; subshell을 나갈 때, subshell_tree에 ast의 root를 push하고,
; 부모프로세스의 subshell_tree의 root에 자식프로세스의 subshell_tree의 root를 add한다.
2-1.lr_parser를 시작할 때 ast와 token_buff는 새로 할당된다.
3.  ')'가 나왔을 때 if (p_stack <= 0) error, else p_stack--하고 subshell_tree에 ast를 push한다.    
3-1. ')'이 나온직후 {'<','>','<<','>>'}내의 연산자가 나왔을 때, 해당하는 프로시저를 호출한다.
4.  '\0'가 나왔을 때 if (p_stack != 0) error 한다.
5.  논리연산자가 나왔을 때 subshell_tree에 논리연산자를 push한다.
; output_exec()호출 시, subshell_tree의 각 node 실행결과에 따라 다음 주소에 있는 논리연산자에서 실행을 계속할지 결정한다.

결론: 문법은 lr_table_grammar_minishell을 따른다.
*/

; 좌순환 제거필요
; first, follow학습하면 될 거같음.
complete_commands -> complete_commands and_or
complete_commands -> and_or

and_or -> pipe_sequence
and_or -> and_or AND_IF pipe_sequence
and_or -> and_or OR_IF pipe_sequence

pipe_sequence -> command 
pipe_sequence -> pipe_sequence PIPE command

command -> simple_command 
command -> subshell
command -> subshell redirect_list

subshell -> PAREN_L term PAREN_R

term -> term and_or
term -> and_or

simple_command -> cmd_prefix cmd_word cmd_suffix 
simple_command -> cmd_prefix cmd_word 
simple_command -> cmd_prefix 
simple_command -> cmd_name cmd_suffix 
simple_command -> cmd_name

cmd_name -> WORD

cmd_word -> WORD

cmd_prefix -> io_redirect 
cmd_prefix -> cmd_prefix io_redirect

; 좌순환 제거와 left factoring이 모두 필요한 생성규칙임.
; factoring이후의 symbol의 first가 LHS의 first와 일치할 경우,
; factoring으로 생겨나는 생성규칙을 약간 변형시키면서,
; 원래 생성규칙에 있는 좌순환을 없앨 수 있는것같음.
; 그럼 GNF가 됨.
cmd_suffix -> io_redirect 
cmd_suffix -> cmd_suffix io_redirect 
cmd_suffix -> WORD 
cmd_suffix -> cmd_suffix WORD

redirect_list -> io_redirect 
redirect_list -> redirect_list io_redirect

io_redirect -> io_file 
io_redirect -> io_here

io_file -> REDIRECT_L filename 
io_file -> REDIRECT_R filename 
io_file -> DGREAT filename

filename -> WORD

io_here -> DLESS here_end

here_end -> WORD
